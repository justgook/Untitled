{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveGeneric #-}
{- |
Module: Capnp.Protocol
Description: Low-level generated module for Protocol.capnp
This module is the generated code for Protocol.capnp, for the
low-level api.
-}
module Capnp.Protocol where
-- Code generated by capnpc-haskell. DO NOT EDIT.
-- Generated from schema file: Protocol.capnp
import Data.Int
import Data.Word
import GHC.Generics (Generic)
import Data.Capnp.Bits (Word1)
import qualified Data.Bits
import qualified Data.Maybe
import qualified Data.ByteString
import qualified Data.Capnp.Classes as C'
import qualified Data.Capnp.Basics as B'
import qualified Data.Capnp.GenHelpers as H'
import qualified Data.Capnp.TraversalLimit as TL'
import qualified Data.Capnp.Untyped as U'
import qualified Data.Capnp.Message as M'
newtype Chat msg = Chat_newtype_ (U'.Struct msg)
instance C'.FromStruct msg (Chat msg) where
    fromStruct = pure . Chat_newtype_
instance C'.ToStruct msg (Chat msg) where
    toStruct (Chat_newtype_ struct) = struct
instance U'.HasMessage (Chat msg) where
    type InMessage (Chat msg) = msg
    message (Chat_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Chat msg) where
    messageDefault = Chat_newtype_ . U'.messageDefault
instance B'.ListElem msg (Chat msg) where
    newtype List msg (Chat msg) = List_Chat (U'.ListOf msg (U'.Struct msg))
    length (List_Chat l) = U'.length l
    index i (List_Chat l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Chat msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Chat msg) where
    fromPtr msg ptr = Chat_newtype_ <$> C'.fromPtr msg ptr
    toPtr (Chat_newtype_ struct) = C'.toPtr struct
instance B'.MutListElem s (Chat (M'.MutMsg s)) where
    setIndex (Chat_newtype_ elt) i (List_Chat l) = U'.setIndex elt i l
    newList msg len = List_Chat <$> U'.allocCompositeList msg 1 1 len
instance C'.Allocate s (Chat (M'.MutMsg s)) where
    new msg = Chat_newtype_ <$> U'.allocStruct msg 1 1
instance C'.IsPtr msg (B'.List msg (Chat msg)) where
    fromPtr msg ptr = List_Chat <$> C'.fromPtr msg ptr
    toPtr (List_Chat l) = C'.toPtr l
get_Chat'id :: U'.ReadCtx m msg => Chat msg -> m Word64
get_Chat'id (Chat_newtype_ struct) = H'.getWordField struct 0 0 0
set_Chat'id :: U'.RWCtx m s => Chat (M'.MutMsg s) -> Word64 -> m ()
set_Chat'id (Chat_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 0 0 0
get_Chat'packages :: U'.ReadCtx m msg => Chat msg -> m (B'.List msg (Package msg))
get_Chat'packages (Chat_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Chat'packages :: U'.ReadCtx m msg => Chat msg -> m Bool
has_Chat'packages(Chat_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Chat'packages :: U'.RWCtx m s => Chat (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Package (M'.MutMsg s))) -> m ()
set_Chat'packages (Chat_newtype_ struct) value = U'.setPtr (C'.toPtr value) 0 struct
new_Chat'packages :: U'.RWCtx m s => Int -> Chat (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (Package (M'.MutMsg s))))
new_Chat'packages len struct = do
    result <- C'.newList (U'.message struct) len
    set_Chat'packages struct result
    pure result
newtype Package msg = Package_newtype_ (U'.Struct msg)
instance C'.FromStruct msg (Package msg) where
    fromStruct = pure . Package_newtype_
instance C'.ToStruct msg (Package msg) where
    toStruct (Package_newtype_ struct) = struct
instance U'.HasMessage (Package msg) where
    type InMessage (Package msg) = msg
    message (Package_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Package msg) where
    messageDefault = Package_newtype_ . U'.messageDefault
instance B'.ListElem msg (Package msg) where
    newtype List msg (Package msg) = List_Package (U'.ListOf msg (U'.Struct msg))
    length (List_Package l) = U'.length l
    index i (List_Package l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Package msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Package msg) where
    fromPtr msg ptr = Package_newtype_ <$> C'.fromPtr msg ptr
    toPtr (Package_newtype_ struct) = C'.toPtr struct
instance B'.MutListElem s (Package (M'.MutMsg s)) where
    setIndex (Package_newtype_ elt) i (List_Package l) = U'.setIndex elt i l
    newList msg len = List_Package <$> U'.allocCompositeList msg 1 3 len
instance C'.Allocate s (Package (M'.MutMsg s)) where
    new msg = Package_newtype_ <$> U'.allocStruct msg 1 3
instance C'.IsPtr msg (B'.List msg (Package msg)) where
    fromPtr msg ptr = List_Package <$> C'.fromPtr msg ptr
    toPtr (List_Package l) = C'.toPtr l
get_Package'from :: U'.ReadCtx m msg => Package msg -> m (Target msg)
get_Package'from (Package_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Package'from :: U'.ReadCtx m msg => Package msg -> m Bool
has_Package'from(Package_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Package'from :: U'.RWCtx m s => Package (M'.MutMsg s) -> (Target (M'.MutMsg s)) -> m ()
set_Package'from (Package_newtype_ struct) value = U'.setPtr (C'.toPtr value) 0 struct
new_Package'from :: U'.RWCtx m s => Package (M'.MutMsg s) -> m ((Target (M'.MutMsg s)))
new_Package'from struct = do
    result <- C'.new (U'.message struct)
    set_Package'from struct result
    pure result
get_Package'to :: U'.ReadCtx m msg => Package msg -> m (Target msg)
get_Package'to (Package_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
has_Package'to :: U'.ReadCtx m msg => Package msg -> m Bool
has_Package'to(Package_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_Package'to :: U'.RWCtx m s => Package (M'.MutMsg s) -> (Target (M'.MutMsg s)) -> m ()
set_Package'to (Package_newtype_ struct) value = U'.setPtr (C'.toPtr value) 1 struct
new_Package'to :: U'.RWCtx m s => Package (M'.MutMsg s) -> m ((Target (M'.MutMsg s)))
new_Package'to struct = do
    result <- C'.new (U'.message struct)
    set_Package'to struct result
    pure result
get_Package'timestamp :: U'.ReadCtx m msg => Package msg -> m Int32
get_Package'timestamp (Package_newtype_ struct) = H'.getWordField struct 0 0 0
set_Package'timestamp :: U'.RWCtx m s => Package (M'.MutMsg s) -> Int32 -> m ()
set_Package'timestamp (Package_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
get_Package'content :: U'.ReadCtx m msg => Package msg -> m (Package'content msg)
get_Package'content (Package_newtype_ struct) = C'.fromStruct struct
newtype Target msg = Target_newtype_ (U'.Struct msg)
instance C'.FromStruct msg (Target msg) where
    fromStruct = pure . Target_newtype_
instance C'.ToStruct msg (Target msg) where
    toStruct (Target_newtype_ struct) = struct
instance U'.HasMessage (Target msg) where
    type InMessage (Target msg) = msg
    message (Target_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Target msg) where
    messageDefault = Target_newtype_ . U'.messageDefault
instance B'.ListElem msg (Target msg) where
    newtype List msg (Target msg) = List_Target (U'.ListOf msg (U'.Struct msg))
    length (List_Target l) = U'.length l
    index i (List_Target l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Target msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Target msg) where
    fromPtr msg ptr = Target_newtype_ <$> C'.fromPtr msg ptr
    toPtr (Target_newtype_ struct) = C'.toPtr struct
instance B'.MutListElem s (Target (M'.MutMsg s)) where
    setIndex (Target_newtype_ elt) i (List_Target l) = U'.setIndex elt i l
    newList msg len = List_Target <$> U'.allocCompositeList msg 2 0 len
instance C'.Allocate s (Target (M'.MutMsg s)) where
    new msg = Target_newtype_ <$> U'.allocStruct msg 2 0
instance C'.IsPtr msg (B'.List msg (Target msg)) where
    fromPtr msg ptr = List_Target <$> C'.fromPtr msg ptr
    toPtr (List_Target l) = C'.toPtr l
data Target' msg
    = Target'global
    | Target'personal Word64
    | Target'unknown' Word16
get_Target' :: U'.ReadCtx m msg => Target msg -> m (Target' msg)
get_Target' (Target_newtype_ struct) = C'.fromStruct struct
set_Target'global :: U'.RWCtx m s => Target (M'.MutMsg s) -> m ()
set_Target'global (Target_newtype_ struct) = H'.setWordField struct (0 :: Word16) 0 0 0
set_Target'personal :: U'.RWCtx m s => Target (M'.MutMsg s) -> Word64 -> m ()
set_Target'personal (Target_newtype_ struct) value = do
    H'.setWordField struct (1 :: Word16) 0 0 0
    H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
set_Target'unknown' :: U'.RWCtx m s => Target (M'.MutMsg s) -> Word16 -> m ()
set_Target'unknown'(Target_newtype_ struct) tagValue = H'.setWordField struct (tagValue :: Word16) 0 0 0
instance C'.FromStruct msg (Target' msg) where
    fromStruct struct = do
        tag <-  H'.getWordField struct 0 0 0
        case tag of
            1 -> Target'personal <$>  H'.getWordField struct 1 0 0
            0 -> pure Target'global
            _ -> pure $ Target'unknown' tag
ping :: Float
ping = C'.fromWord 1092616192
newtype Package'content msg = Package'content_newtype_ (U'.Struct msg)
instance C'.FromStruct msg (Package'content msg) where
    fromStruct = pure . Package'content_newtype_
instance C'.ToStruct msg (Package'content msg) where
    toStruct (Package'content_newtype_ struct) = struct
instance U'.HasMessage (Package'content msg) where
    type InMessage (Package'content msg) = msg
    message (Package'content_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Package'content msg) where
    messageDefault = Package'content_newtype_ . U'.messageDefault
data Package'content' msg
    = Package'content'message (B'.Text msg)
    | Package'content'pack (B'.Data msg)
    | Package'content'unknown' Word16
get_Package'content' :: U'.ReadCtx m msg => Package'content msg -> m (Package'content' msg)
get_Package'content' (Package'content_newtype_ struct) = C'.fromStruct struct
set_Package'content'message :: U'.RWCtx m s => Package'content (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Package'content'message(Package'content_newtype_ struct) value = do
    H'.setWordField struct (0 :: Word16) 0 32 0
    U'.setPtr (C'.toPtr value) 2 struct
new_Package'content'message :: U'.RWCtx m s => Int -> Package'content (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Package'content'message len struct = do
    result <- B'.newText (U'.message struct) len
    set_Package'content'message struct result
    pure result
set_Package'content'pack :: U'.RWCtx m s => Package'content (M'.MutMsg s) -> (B'.Data (M'.MutMsg s)) -> m ()
set_Package'content'pack(Package'content_newtype_ struct) value = do
    H'.setWordField struct (1 :: Word16) 0 32 0
    U'.setPtr (C'.toPtr value) 2 struct
new_Package'content'pack :: U'.RWCtx m s => Int -> Package'content (M'.MutMsg s) -> m ((B'.Data (M'.MutMsg s)))
new_Package'content'pack len struct = do
    result <- B'.newData (U'.message struct) len
    set_Package'content'pack struct result
    pure result
set_Package'content'unknown' :: U'.RWCtx m s => Package'content (M'.MutMsg s) -> Word16 -> m ()
set_Package'content'unknown'(Package'content_newtype_ struct) tagValue = H'.setWordField struct (tagValue :: Word16) 0 32 0
instance C'.FromStruct msg (Package'content' msg) where
    fromStruct struct = do
        tag <-  H'.getWordField struct 0 32 0
        case tag of
            1 -> Package'content'pack <$>  (U'.getPtr 2 struct >>= C'.fromPtr (U'.message struct))
            0 -> Package'content'message <$>  (U'.getPtr 2 struct >>= C'.fromPtr (U'.message struct))
            _ -> pure $ Package'content'unknown' tag