{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveGeneric #-}
{- |
Module: Capnp.Addressbook
Description: Low-level generated module for addressbook.capnp
This module is the generated code for addressbook.capnp, for the
low-level api.
-}
module Capnp.Addressbook where
-- Code generated by capnpc-haskell. DO NOT EDIT.
-- Generated from schema file: addressbook.capnp
import Data.Int
import Data.Word
import GHC.Generics (Generic)
import Data.Capnp.Bits (Word1)
import qualified Data.Bits
import qualified Data.Maybe
import qualified Data.ByteString
import qualified Data.Capnp.Classes as C'
import qualified Data.Capnp.Basics as B'
import qualified Data.Capnp.GenHelpers as H'
import qualified Data.Capnp.TraversalLimit as TL'
import qualified Data.Capnp.Untyped as U'
import qualified Data.Capnp.Message as M'
newtype AddressBook msg = AddressBook_newtype_ (U'.Struct msg)
instance C'.FromStruct msg (AddressBook msg) where
    fromStruct = pure . AddressBook_newtype_
instance C'.ToStruct msg (AddressBook msg) where
    toStruct (AddressBook_newtype_ struct) = struct
instance U'.HasMessage (AddressBook msg) where
    type InMessage (AddressBook msg) = msg
    message (AddressBook_newtype_ struct) = U'.message struct
instance U'.MessageDefault (AddressBook msg) where
    messageDefault = AddressBook_newtype_ . U'.messageDefault
instance B'.ListElem msg (AddressBook msg) where
    newtype List msg (AddressBook msg) = List_AddressBook (U'.ListOf msg (U'.Struct msg))
    length (List_AddressBook l) = U'.length l
    index i (List_AddressBook l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (AddressBook msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (AddressBook msg) where
    fromPtr msg ptr = AddressBook_newtype_ <$> C'.fromPtr msg ptr
    toPtr (AddressBook_newtype_ struct) = C'.toPtr struct
instance B'.MutListElem s (AddressBook (M'.MutMsg s)) where
    setIndex (AddressBook_newtype_ elt) i (List_AddressBook l) = U'.setIndex elt i l
    newList msg len = List_AddressBook <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (AddressBook (M'.MutMsg s)) where
    new msg = AddressBook_newtype_ <$> U'.allocStruct msg 0 1
instance C'.IsPtr msg (B'.List msg (AddressBook msg)) where
    fromPtr msg ptr = List_AddressBook <$> C'.fromPtr msg ptr
    toPtr (List_AddressBook l) = C'.toPtr l
get_AddressBook'people :: U'.ReadCtx m msg => AddressBook msg -> m (B'.List msg (Person msg))
get_AddressBook'people (AddressBook_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_AddressBook'people :: U'.ReadCtx m msg => AddressBook msg -> m Bool
has_AddressBook'people(AddressBook_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_AddressBook'people :: U'.RWCtx m s => AddressBook (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Person (M'.MutMsg s))) -> m ()
set_AddressBook'people (AddressBook_newtype_ struct) value = U'.setPtr (C'.toPtr value) 0 struct
new_AddressBook'people :: U'.RWCtx m s => Int -> AddressBook (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (Person (M'.MutMsg s))))
new_AddressBook'people len struct = do
    result <- C'.newList (U'.message struct) len
    set_AddressBook'people struct result
    pure result
newtype Person msg = Person_newtype_ (U'.Struct msg)
instance C'.FromStruct msg (Person msg) where
    fromStruct = pure . Person_newtype_
instance C'.ToStruct msg (Person msg) where
    toStruct (Person_newtype_ struct) = struct
instance U'.HasMessage (Person msg) where
    type InMessage (Person msg) = msg
    message (Person_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Person msg) where
    messageDefault = Person_newtype_ . U'.messageDefault
instance B'.ListElem msg (Person msg) where
    newtype List msg (Person msg) = List_Person (U'.ListOf msg (U'.Struct msg))
    length (List_Person l) = U'.length l
    index i (List_Person l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Person msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Person msg) where
    fromPtr msg ptr = Person_newtype_ <$> C'.fromPtr msg ptr
    toPtr (Person_newtype_ struct) = C'.toPtr struct
instance B'.MutListElem s (Person (M'.MutMsg s)) where
    setIndex (Person_newtype_ elt) i (List_Person l) = U'.setIndex elt i l
    newList msg len = List_Person <$> U'.allocCompositeList msg 1 4 len
instance C'.Allocate s (Person (M'.MutMsg s)) where
    new msg = Person_newtype_ <$> U'.allocStruct msg 1 4
instance C'.IsPtr msg (B'.List msg (Person msg)) where
    fromPtr msg ptr = List_Person <$> C'.fromPtr msg ptr
    toPtr (List_Person l) = C'.toPtr l
get_Person'id :: U'.ReadCtx m msg => Person msg -> m Word32
get_Person'id (Person_newtype_ struct) = H'.getWordField struct 0 0 0
set_Person'id :: U'.RWCtx m s => Person (M'.MutMsg s) -> Word32 -> m ()
set_Person'id (Person_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
get_Person'name :: U'.ReadCtx m msg => Person msg -> m (B'.Text msg)
get_Person'name (Person_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Person'name :: U'.ReadCtx m msg => Person msg -> m Bool
has_Person'name(Person_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Person'name :: U'.RWCtx m s => Person (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Person'name (Person_newtype_ struct) value = U'.setPtr (C'.toPtr value) 0 struct
new_Person'name :: U'.RWCtx m s => Int -> Person (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Person'name len struct = do
    result <- B'.newText (U'.message struct) len
    set_Person'name struct result
    pure result
get_Person'email :: U'.ReadCtx m msg => Person msg -> m (B'.Text msg)
get_Person'email (Person_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
has_Person'email :: U'.ReadCtx m msg => Person msg -> m Bool
has_Person'email(Person_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_Person'email :: U'.RWCtx m s => Person (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Person'email (Person_newtype_ struct) value = U'.setPtr (C'.toPtr value) 1 struct
new_Person'email :: U'.RWCtx m s => Int -> Person (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Person'email len struct = do
    result <- B'.newText (U'.message struct) len
    set_Person'email struct result
    pure result
get_Person'phones :: U'.ReadCtx m msg => Person msg -> m (B'.List msg (Person'PhoneNumber msg))
get_Person'phones (Person_newtype_ struct) =
    U'.getPtr 2 struct
    >>= C'.fromPtr (U'.message struct)
has_Person'phones :: U'.ReadCtx m msg => Person msg -> m Bool
has_Person'phones(Person_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 2 struct
set_Person'phones :: U'.RWCtx m s => Person (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Person'PhoneNumber (M'.MutMsg s))) -> m ()
set_Person'phones (Person_newtype_ struct) value = U'.setPtr (C'.toPtr value) 2 struct
new_Person'phones :: U'.RWCtx m s => Int -> Person (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (Person'PhoneNumber (M'.MutMsg s))))
new_Person'phones len struct = do
    result <- C'.newList (U'.message struct) len
    set_Person'phones struct result
    pure result
get_Person'employment :: U'.ReadCtx m msg => Person msg -> m (Person'employment msg)
get_Person'employment (Person_newtype_ struct) = C'.fromStruct struct
newtype Person'PhoneNumber msg = Person'PhoneNumber_newtype_ (U'.Struct msg)
instance C'.FromStruct msg (Person'PhoneNumber msg) where
    fromStruct = pure . Person'PhoneNumber_newtype_
instance C'.ToStruct msg (Person'PhoneNumber msg) where
    toStruct (Person'PhoneNumber_newtype_ struct) = struct
instance U'.HasMessage (Person'PhoneNumber msg) where
    type InMessage (Person'PhoneNumber msg) = msg
    message (Person'PhoneNumber_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Person'PhoneNumber msg) where
    messageDefault = Person'PhoneNumber_newtype_ . U'.messageDefault
instance B'.ListElem msg (Person'PhoneNumber msg) where
    newtype List msg (Person'PhoneNumber msg) = List_Person'PhoneNumber (U'.ListOf msg (U'.Struct msg))
    length (List_Person'PhoneNumber l) = U'.length l
    index i (List_Person'PhoneNumber l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Person'PhoneNumber msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Person'PhoneNumber msg) where
    fromPtr msg ptr = Person'PhoneNumber_newtype_ <$> C'.fromPtr msg ptr
    toPtr (Person'PhoneNumber_newtype_ struct) = C'.toPtr struct
instance B'.MutListElem s (Person'PhoneNumber (M'.MutMsg s)) where
    setIndex (Person'PhoneNumber_newtype_ elt) i (List_Person'PhoneNumber l) = U'.setIndex elt i l
    newList msg len = List_Person'PhoneNumber <$> U'.allocCompositeList msg 1 1 len
instance C'.Allocate s (Person'PhoneNumber (M'.MutMsg s)) where
    new msg = Person'PhoneNumber_newtype_ <$> U'.allocStruct msg 1 1
instance C'.IsPtr msg (B'.List msg (Person'PhoneNumber msg)) where
    fromPtr msg ptr = List_Person'PhoneNumber <$> C'.fromPtr msg ptr
    toPtr (List_Person'PhoneNumber l) = C'.toPtr l
get_Person'PhoneNumber'number :: U'.ReadCtx m msg => Person'PhoneNumber msg -> m (B'.Text msg)
get_Person'PhoneNumber'number (Person'PhoneNumber_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Person'PhoneNumber'number :: U'.ReadCtx m msg => Person'PhoneNumber msg -> m Bool
has_Person'PhoneNumber'number(Person'PhoneNumber_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Person'PhoneNumber'number :: U'.RWCtx m s => Person'PhoneNumber (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Person'PhoneNumber'number (Person'PhoneNumber_newtype_ struct) value = U'.setPtr (C'.toPtr value) 0 struct
new_Person'PhoneNumber'number :: U'.RWCtx m s => Int -> Person'PhoneNumber (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Person'PhoneNumber'number len struct = do
    result <- B'.newText (U'.message struct) len
    set_Person'PhoneNumber'number struct result
    pure result
get_Person'PhoneNumber'type_ :: U'.ReadCtx m msg => Person'PhoneNumber msg -> m Person'PhoneNumber'Type
get_Person'PhoneNumber'type_ (Person'PhoneNumber_newtype_ struct) = H'.getWordField struct 0 0 0
set_Person'PhoneNumber'type_ :: U'.RWCtx m s => Person'PhoneNumber (M'.MutMsg s) -> Person'PhoneNumber'Type -> m ()
set_Person'PhoneNumber'type_ (Person'PhoneNumber_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 0 0
newtype Person'employment msg = Person'employment_newtype_ (U'.Struct msg)
instance C'.FromStruct msg (Person'employment msg) where
    fromStruct = pure . Person'employment_newtype_
instance C'.ToStruct msg (Person'employment msg) where
    toStruct (Person'employment_newtype_ struct) = struct
instance U'.HasMessage (Person'employment msg) where
    type InMessage (Person'employment msg) = msg
    message (Person'employment_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Person'employment msg) where
    messageDefault = Person'employment_newtype_ . U'.messageDefault
data Person'employment' msg
    = Person'employment'unemployed
    | Person'employment'employer (B'.Text msg)
    | Person'employment'school (B'.Text msg)
    | Person'employment'selfEmployed
    | Person'employment'unknown' Word16
get_Person'employment' :: U'.ReadCtx m msg => Person'employment msg -> m (Person'employment' msg)
get_Person'employment' (Person'employment_newtype_ struct) = C'.fromStruct struct
set_Person'employment'unemployed :: U'.RWCtx m s => Person'employment (M'.MutMsg s) -> m ()
set_Person'employment'unemployed (Person'employment_newtype_ struct) = H'.setWordField struct (0 :: Word16) 0 32 0
set_Person'employment'employer :: U'.RWCtx m s => Person'employment (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Person'employment'employer(Person'employment_newtype_ struct) value = do
    H'.setWordField struct (1 :: Word16) 0 32 0
    U'.setPtr (C'.toPtr value) 3 struct
new_Person'employment'employer :: U'.RWCtx m s => Int -> Person'employment (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Person'employment'employer len struct = do
    result <- B'.newText (U'.message struct) len
    set_Person'employment'employer struct result
    pure result
set_Person'employment'school :: U'.RWCtx m s => Person'employment (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Person'employment'school(Person'employment_newtype_ struct) value = do
    H'.setWordField struct (2 :: Word16) 0 32 0
    U'.setPtr (C'.toPtr value) 3 struct
new_Person'employment'school :: U'.RWCtx m s => Int -> Person'employment (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Person'employment'school len struct = do
    result <- B'.newText (U'.message struct) len
    set_Person'employment'school struct result
    pure result
set_Person'employment'selfEmployed :: U'.RWCtx m s => Person'employment (M'.MutMsg s) -> m ()
set_Person'employment'selfEmployed (Person'employment_newtype_ struct) = H'.setWordField struct (3 :: Word16) 0 32 0
set_Person'employment'unknown' :: U'.RWCtx m s => Person'employment (M'.MutMsg s) -> Word16 -> m ()
set_Person'employment'unknown'(Person'employment_newtype_ struct) tagValue = H'.setWordField struct (tagValue :: Word16) 0 32 0
instance C'.FromStruct msg (Person'employment' msg) where
    fromStruct struct = do
        tag <-  H'.getWordField struct 0 32 0
        case tag of
            3 -> pure Person'employment'selfEmployed
            2 -> Person'employment'school <$>  (U'.getPtr 3 struct >>= C'.fromPtr (U'.message struct))
            1 -> Person'employment'employer <$>  (U'.getPtr 3 struct >>= C'.fromPtr (U'.message struct))
            0 -> pure Person'employment'unemployed
            _ -> pure $ Person'employment'unknown' tag
data Person'PhoneNumber'Type
    = Person'PhoneNumber'Type'mobile
    | Person'PhoneNumber'Type'home
    | Person'PhoneNumber'Type'work
    | Person'PhoneNumber'Type'unknown' Word16
    deriving(Show,Read,Eq,Generic)
instance Enum Person'PhoneNumber'Type where
    toEnum = C'.fromWord . fromIntegral
    fromEnum = fromIntegral . C'.toWord
instance C'.IsWord Person'PhoneNumber'Type where
    fromWord n = go (fromIntegral n :: Word16) where
        go 0 = Person'PhoneNumber'Type'mobile
        go 1 = Person'PhoneNumber'Type'home
        go 2 = Person'PhoneNumber'Type'work
        go tag = Person'PhoneNumber'Type'unknown' (fromIntegral tag)
    toWord Person'PhoneNumber'Type'mobile = 0
    toWord Person'PhoneNumber'Type'home = 1
    toWord Person'PhoneNumber'Type'work = 2
    toWord (Person'PhoneNumber'Type'unknown' tag) = fromIntegral tag
instance B'.ListElem msg Person'PhoneNumber'Type where
    newtype List msg Person'PhoneNumber'Type = List_Person'PhoneNumber'Type (U'.ListOf msg Word16)
    length (List_Person'PhoneNumber'Type l) = U'.length l
    index i (List_Person'PhoneNumber'Type l) = (C'.fromWord . fromIntegral) <$> U'.index i l
instance B'.MutListElem s Person'PhoneNumber'Type where
    setIndex elt i (List_Person'PhoneNumber'Type l) = U'.setIndex (fromIntegral $ C'.toWord elt) i l
    newList msg size = List_Person'PhoneNumber'Type <$> U'.allocList16 msg size
instance C'.IsPtr msg (B'.List msg Person'PhoneNumber'Type) where
    fromPtr msg ptr = List_Person'PhoneNumber'Type <$> C'.fromPtr msg ptr
    toPtr (List_Person'PhoneNumber'Type l) = C'.toPtr l